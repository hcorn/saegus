<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>analyze &mdash; saegus 0.1.2 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="saegus 0.1.2 documentation" href="contents.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">saegus 0.1.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="analyze">
<h1><code class="xref py py-mod docutils literal"><span class="pre">analyze</span></code><a class="headerlink" href="#analyze" title="Permalink to this headline">¶</a></h1>
<p>Imports:</p>
<blockquote>
<div><ul class="simple">
<li>import simuPOP as sim</li>
<li>import csv</li>
<li>import math</li>
<li>import numpy as np</li>
<li>import pandas as pd</li>
<li>import collections as col</li>
<li>import os</li>
<li>from scipy import linalg</li>
<li>import matplotlib.pyplot as plt</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="Frq">
<em class="property">class </em><code class="descname">Frq</code><a class="headerlink" href="#Frq" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Assumes a quantitative trait additive model &#8211; saegus 0.1.2</td>
</tr>
</tbody>
</table>
<p>A class to encapsulate information about alleles at all loci Requires a
list of loci, a dictionary of alleles and allele effects used to determine
phenotypes for population</p>
<blockquote>
<div><dl class="method">
<dt id="Frq.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pop</em>, <em>loci</em>, <em>alleles</em>, <em>allele_effects</em><span class="sig-paren">)</span><a class="headerlink" href="#Frq.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>alleles</strong> (<em>dict</em>) &#8211; Dictionary keyed by locus and valued by a list of
alleles present at that locus.</li>
<li><strong>allele_effects</strong> (<em>dict</em>) &#8211; Dictionary keyed by locus and valued by a</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>sub-dictionary of effects for the alleles at that locus.
:param list loci: List of loci as integers.
:param pop: simuPOP.Population</p>
</dd></dl>

<dl class="docutils">
<dt>def rank_allele_effects(self, pop, loci, alleles,</dt>
<dd><blockquote class="first">
<div>allele_effects):</div></blockquote>
<p>&#8220;&#8221;&#8221;
Collects information about alleles at quantitative trait loci into a
dictionary. Determines favorable/unfavorable allele and corresponding
frequency. Keys of quantitative_trait_alleles have similar hierarchy
for both the alleles and their frequencies.
:param pop:
:param loci:
:param alleles:
:param allele_effects:</p>
<p>&#8220;&#8221;&#8221;
quantitative_trait_alleles = {}
quantitative_trait_alleles[&#8216;effects&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;alleles&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;favorable&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;unfavorable&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;frequency&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;favorable&#8217;] = col.OrderedDict()
quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;unfavorable&#8217;] = col.OrderedDict()
for locus in loci:</p>
<blockquote>
<div><p>temp_effects = []
for allele in alleles[locus]:</p>
<blockquote>
<div>temp_effects.append(allele_effects[locus][allele])</div></blockquote>
<p>quantitative_trait_alleles[&#8216;effects&#8217;][locus] = temp_effects</p>
</div></blockquote>
<dl class="docutils">
<dt>for locus in loci:</dt>
<dd><dl class="first last docutils">
<dt>for allele in alleles[locus]:</dt>
<dd><dl class="first last docutils">
<dt>if allele_effects[locus][allele] == max(</dt>
<dd><blockquote class="first">
<div>quantitative_trait_alleles[&#8216;effects&#8217;][locus]):</div></blockquote>
<dl class="last docutils">
<dt>quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;favorable&#8217;][locus] =</dt>
<dd>allele</dd>
</dl>
</dd>
<dt>if allele_effects[locus][allele] == min(</dt>
<dd><blockquote class="first">
<div>quantitative_trait_alleles[&#8216;effects&#8217;][locus]):</div></blockquote>
<dl class="last docutils">
<dt>quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;unfavorable&#8217;][locus] =</dt>
<dd>allele</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>for locus, allele in quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;favorable&#8217;].items():</dt>
<dd><dl class="first last docutils">
<dt>quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;favorable&#8217;][locus] = </dt>
<dd>pop.dvars().alleleFreq[locus][allele]</dd>
</dl>
</dd>
<dt>for locus, allele in quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;unfavorable&#8217;].items():</dt>
<dd><dl class="first last docutils">
<dt>quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;unfavorable&#8217;][locus] =</dt>
<dd>pop.dvars().alleleFreq[locus][allele]</dd>
</dl>
</dd>
<dt>for i in range(pop.numSubPop()):</dt>
<dd><dl class="first last docutils">
<dt>for locus, allele in quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;favorable&#8217;].items():</dt>
<dd><dl class="first last docutils">
<dt>quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;favorable&#8217;][i, locus] </dt>
<dd>= pop.dvars(i).alleleFreq[locus][allele]</dd>
</dl>
</dd>
<dt>for locus, allele in quantitative_trait_alleles[&#8216;alleles&#8217;][&#8216;unfavorable&#8217;].items():</dt>
<dd><dl class="first last docutils">
<dt>quantitative_trait_alleles[&#8216;frequency&#8217;][&#8216;unfavorable&#8217;][i,locus]</dt>
<dd>= pop.dvars(i).alleleFreq[locus][allele]</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="last">return quantitative_trait_alleles</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">allele_frq_table(pop, number_gens, allele_frq_data, recombination_rates, genetic_map):</code></dt>
<dd><p>Tabulates useful information about each locus and allele frequency</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pop</strong> &#8211; Population with multiple sub-populations. Usually represents multiple generations of recurrent selection or drift.</li>
<li><strong>number_gens</strong> (<em>int</em>) &#8211; Number of generations of selection or drift</li>
<li><strong>allele_frq_data</strong> (<em>dict</em>) &#8211; Allele frequency data and the major/minor alleles at each locus.</li>
<li><strong>recombination_rates</strong> (<em>list</em>) &#8211; Recombination rates for each locus in order.</li>
<li><strong>genetic_map</strong> (<em>pd.DataFrame</em>) &#8211; Chromosome:cM position correspondence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>abs_idex: Absolute index of locus</li>
<li>chrom: Chromosome</li>
<li>locus: Relative index of locus</li>
<li>major: Major allele</li>
<li>minor: Minor allele</li>
<li>recom_rate: Probability of recombination immediately <em>after</em> locus</li>
<li>cM: centiMorgan position on genetic map</li>
<li>v: miniature diagram where <cite>*</cite> is a breakpoint and <cite>|</cite> is a non-recombining locus</li>
<li>generation_labels: Generation number prefixed by <cite>G</cite>, frequency of minor allele at locus</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="9%" />
<col width="16%" />
<col width="8%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">abs_index</th>
<th class="head">chrom</th>
<th class="head">locus</th>
<th class="head">major</th>
<th class="head">minor</th>
<th class="head">recom_rate</th>
<th class="head">cM</th>
<th class="head">v</th>
<th class="head">G_0</th>
<th class="head">G_2</th>
<th class="head">G_4</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0.00</td>
<td>-4.8</td>
<td><cite>|</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0.01</td>
<td>-4.6</td>
<td><cite>|</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-even"><td>2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>0.00</td>
<td>-4.4</td>
<td><cite>*</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>0.00</td>
<td>-4.2</td>
<td><cite>|</cite></td>
<td>0.1</td>
<td>0.2</td>
<td>0.3</td>
</tr>
<tr class="row-even"><td>4</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>0.00</td>
<td>-4.0</td>
<td><cite>|</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>1</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>0.00</td>
<td>-3.8</td>
<td><cite>|</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-even"><td>6</td>
<td>1</td>
<td>6</td>
<td>2</td>
<td>0</td>
<td>0.01</td>
<td>-3.6</td>
<td><cite>|</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>1</td>
<td>7</td>
<td>1</td>
<td>3</td>
<td>0.00</td>
<td>-3.4</td>
<td><cite>*</cite></td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<div class="code python highlight-python"><div class="highlight"><pre><span></span>  allele_data = analyze.Frq(pop, triplet_qtloci[0], alleles_by_locus, qt_allele_effects[0])
  allele_frequencies = allele_data.allele_frequencies(pop, range(pop.totNumLoci())
  allele_frequency_table = selection_qtd.allele_frq_table(pop, 10, allele_frq_data, recombination_rates,
                                                        genetic_map)






def qt_allele_table(self, qt_alleles, allele_effects):
    &quot;&quot;&quot;
    Generates a pd.DataFrame object of data relevant to quantitative
    trait alleles across all generations.
    :param qt_alleles:
    :type qt_alleles:
    :param allele_effects:
    :type allele_effects:
    :return:
    :rtype:
    &quot;&quot;&quot;
    qtdata = {}
    data_columns = [&#39;abs_index&#39;, &#39;chrom&#39;, &#39;locus&#39;, &#39;cM&#39;,
     &#39;favorable&#39;, &#39;fav_effect&#39;, &#39;unfavorable&#39;, &#39;unfav_effect&#39;,
                    &#39;effect_diff&#39;]

    generation_labels = [&#39;G_&#39;+str(i)
                         for i in range(0, self.pop.dvars().gen+1, 2)]
    data_columns = data_columns + generation_labels + [&#39;aggregate&#39;]

    chromosomes = []
    relative_loci = []
    for locus in self.pop.dvars().triplet_qtl:
        pair = self.pop.chromLocusPair(locus)
        chromosomes.append(pair[0]+1)
        relative_loci.append(pair[1])


    qtdata[&#39;chrom&#39;] = chromosomes
    qtdata[&#39;locus&#39;] = relative_loci
    qtdata[&#39;abs_index&#39;] = [locus for locus in self.pop.dvars().triplet_qtl]
    qtdata[&#39;favorable&#39;] = [qt_alleles[&#39;alleles&#39;][&#39;favorable&#39;][locus] for
                           locus in self.pop.dvars().triplet_qtl]

    qtdata[&#39;fav_effect&#39;] = [allele_effects[locus][allele]
                            for locus, allele in qt_alleles[&#39;alleles&#39;][&#39;favorable&#39;].items()]

    qtdata[&#39;unfavorable&#39;] = [qt_alleles[&#39;alleles&#39;][&#39;unfavorable&#39;][locus]
                             for locus in self.pop.dvars().triplet_qtl]

    qtdata[&#39;unfav_effect&#39;] = [allele_effects[locus][allele]
                              for locus, allele in qt_alleles[&#39;alleles&#39;][&#39;unfavorable&#39;].items()]

    qtdata[&#39;effect_diff&#39;] = [allele_effects[locus][qt_alleles[&#39;alleles&#39;][&#39;favorable&#39;][locus]] -
                             allele_effects[locus][qt_alleles[&#39;alleles&#39;][&#39;unfavorable&#39;][locus]]
                             for locus in self.pop.dvars().triplet_qtl]
    for subpop, label in zip(range(self.pop.numSubPop()),
                             generation_labels):
        qtdata[label] = [qt_alleles[&#39;frequency&#39;][&#39;favorable&#39;][subpop,
                                                              locus] for
                         locus in self.pop.dvars().triplet_qtl]
    qtdata[&#39;aggregate&#39;] = [qt_alleles[&#39;frequency&#39;][&#39;favorable&#39;][locus]
                           for locus in self.pop.dvars().triplet_qtl]
    qta_table = pd.DataFrame(qtdata, columns=data_columns)
    return qta_table
</pre></div>
</div>
</dd></dl>

<dl class="docutils">
<dt>def collect_haplotype_data(pop, allele_effects, quantitative_trait_loci):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param pop:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">type pop:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param allele_effects:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type allele_effects:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param quantitative_trait_loci:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type quantitative_trait_loci:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>&#8220;&#8221;&#8220;</p>
<p>haplotypes = {}
haplotypes[&#8216;loci&#8217;] = {}
for k, i in enumerate(range(0, len(quantitative_trait_loci), 3)):</p>
<blockquote>
<div><dl class="docutils">
<dt>haplotypes[&#8216;loci&#8217;][k] = (quantitative_trait_loci[i],</dt>
<dd>quantitative_trait_loci[i+1],
quantitative_trait_loci[i+2])</dd>
</dl>
</div></blockquote>
<p>haplotypes[&#8216;alleles&#8217;] = {}
haplotypes[&#8216;effect&#8217;] = {}
haplotypes[&#8216;frequency&#8217;] = {}
for loci in haplotypes[&#8216;loci&#8217;].values():</p>
<blockquote>
<div><p>haplotypes[&#8216;frequency&#8217;][loci] = {}
for sp in range(pop.numSubPop()):</p>
<blockquote>
<div>haplotypes[&#8216;frequency&#8217;][loci][sp] = {}</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>sim.stat(pop, haploFreq=list(haplotypes[&#8216;loci&#8217;].values()),</dt>
<dd>vars=[&#8216;haploFreq&#8217;, &#8216;haploFreq_sp&#8217;])</dd>
<dt>for k, v in haplotypes[&#8216;loci&#8217;].items():</dt>
<dd>haplotypes[&#8216;alleles&#8217;][v] = list(pop.dvars(0).haploFreq[v].keys())</dd>
<dt>for sp in range(pop.numSubPop()):</dt>
<dd><dl class="first last docutils">
<dt>for loci, triplet in haplotypes[&#8216;alleles&#8217;].items():</dt>
<dd><dl class="first last docutils">
<dt>for alleles in triplet:</dt>
<dd><dl class="first last docutils">
<dt>haplotypes[&#8216;frequency&#8217;][loci][sp][alleles] = pop.dvars(</dt>
<dd>sp).haploFreq[loci][alleles]</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>for htype, triplets in haplotypes[&#8216;alleles&#8217;].items():</dt>
<dd><p class="first">haplotypes[&#8216;effect&#8217;][htype] = {}
for trip in triplets:</p>
<blockquote class="last">
<div>htype_effect = allele_effects[htype[0]][trip[0]] +allele_effects[htype[1]][trip[1]] +allele_effects[htype[2]][trip[2]]
haplotypes[&#8216;effect&#8217;][htype][trip] = htype_effect</div></blockquote>
</dd>
</dl>
<p class="last">return haplotypes</p>
</dd>
<dt>def generate_haplotype_data_table(pop, haplotype_data):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Generates a table for easy analysis and visualization of haplotypes,
effects, frequencies and locations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param pop:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">type pop:</th><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param haplotype_data:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type haplotype_data:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>&#8220;&#8221;&#8221;
integer_to_snp = {0: &#8216;A&#8217;, 1: &#8216;C&#8217;, 2: &#8216;G&#8217;, 3: &#8216;T&#8217;, 4: &#8216;+&#8217;, 5: &#8216;-&#8216;}
haplotype_table = []
data_columns = [&#8216;centered_on&#8217;, &#8216;relative_position&#8217;, &#8216;chromosome&#8217;,</p>
<blockquote>
<div>&#8216;haplotype&#8217;, &#8216;effect&#8217;]</div></blockquote>
<dl class="docutils">
<dt>generation_columns = [&#8216;<a href="#id7"><span class="problematic" id="id8">G_</span></a>&#8216;+str(i) for i in range(0, 2*(pop.numSubPop()),</dt>
<dd>2)]</dd>
</dl>
<p>data_columns.extend(generation_columns)
for locus in haplotype_data[&#8216;loci&#8217;].values():</p>
<blockquote>
<div><dl class="docutils">
<dt>for triplet in haplotype_data[&#8216;alleles&#8217;][locus]:</dt>
<dd><dl class="first docutils">
<dt>generational_frequencies = [haplotype_data[&#8216;frequency&#8217;][locus][sp][triplet]</dt>
<dd>for sp in range(pop.numSubPop())]</dd>
</dl>
<p>effect = haplotype_data[&#8216;effect&#8217;][locus][triplet]
snp_triplet = integer_to_snp[triplet[0]] + </p>
<blockquote>
<div>integer_to_snp[triplet[1]] + integer_to_snp[triplet[2]]</div></blockquote>
<p>chromosome = pop.chromLocusPair(locus[1])[0] + 1
relative_locus = pop.chromLocusPair(locus[1])[1]
row = [locus[1]] + </p>
<blockquote>
<div>[relative_locus] +[chromosome] + [snp_triplet] + [effect] + generational_frequencies</div></blockquote>
<p class="last">haplotype_table.append(row)</p>
</dd>
</dl>
</div></blockquote>
<p class="last">return pd.DataFrame(haplotype_table, columns=data_columns)</p>
</dd>
<dt>def plot_frequency_vs_effect(pop, haplotype_table, plot_title,</dt>
<dd><blockquote class="first">
<div>plot_file_name,
color_map=&#8217;Dark2&#8217;):</div></blockquote>
<p>&#8220;&#8221;&#8221;
Uses the haplotype data table to arrange data into a chromosome
color coded multiple generation plot which shows the change in
haplotype frequency over time. Haplotypes are dots with fixed
x-position which shows their effect. Their motion along the y-axis
which is frequency shows changes over time.
:param plot_title:
:param plot_file_name:
:param color_map:
:param pop:
:param haplotype_table:
&#8220;&#8221;&#8220;</p>
<p>plt.style.use(&#8216;ggplot&#8217;)</p>
<p>distinct_chromosomes = list(set(haplotype_table[&#8216;chromosome&#8217;]))
number_of_different_colors = len(distinct_chromosomes)
generation_labels = [&#8216;<a href="#id9"><span class="problematic" id="id10">G_</span></a>&#8216; + &#8216;{&#8216; + str(i) + &#8216;}&#8217; for i in</p>
<blockquote>
<div>range(0, 2*(pop.numSubPop()), 2)]</div></blockquote>
<p>generations = [&#8216;<a href="#id11"><span class="problematic" id="id12">G_</span></a>&#8216; + str(i) for i in range(0, 2*(pop.numSubPop()), 2)]</p>
<p>c_map = plt.get_cmap(color_map)</p>
<p>colors = c_map(np.linspace(0, 1, number_of_different_colors))</p>
<dl class="docutils">
<dt>chromosome_colors = {distinct_chromosomes[i]: colors[i] for i in</dt>
<dd>range(number_of_different_colors)}</dd>
</dl>
<p>effect_frq_by_chromosome = {}</p>
<dl class="docutils">
<dt>for sp in range(pop.numSubPop()):</dt>
<dd><p class="first">effect_frq_by_chromosome[sp] = {}
for chrom in distinct_chromosomes:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>haplotype_frequencies = np.array(</dt>
<dd><dl class="first last docutils">
<dt>haplotype_table.loc[</dt>
<dd>haplotype_table[&#8216;chromosome&#8217;] == chrom][generations[sp]])</dd>
</dl>
</dd>
<dt>haplotype_effects = np.array(</dt>
<dd><dl class="first last docutils">
<dt>haplotype_table.loc[</dt>
<dd>haplotype_table[&#8216;chromosome&#8217;] == chrom][&#8216;effect&#8217;])</dd>
</dl>
</dd>
<dt>effect_frq_by_chromosome[sp][chrom] = np.array([</dt>
<dd>haplotype_frequencies, haplotype_effects])</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p># Figure parameters
maximum_haplotype_effect = max(haplotype_table[&#8216;effect&#8217;])</p>
<p>generations = [&#8216;<a href="#id13"><span class="problematic" id="id14">G_</span></a>&#8216;+str(i) for i in range(0, 2*(pop.numSubPop()) + 1, 2)]</p>
<p>f, ax = plt.subplots(pop.numSubPop(), 1, figsize=(15, 40))
for sp in range(pop.numSubPop()):</p>
<blockquote>
<div><p>ax[sp].set_xlim(-0.5, maximum_haplotype_effect+4)
ax[sp].set_ylim(-0.1, 1.1)
for chrom in distinct_chromosomes:</p>
<blockquote>
<div><dl class="docutils">
<dt>ax[sp].plot(effect_frq_by_chromosome[sp][chrom][1],</dt>
<dd><p class="first">effect_frq_by_chromosome[sp][chrom][0],
markersize=8, linewidth=0.0, marker=&#8217;*&#8217;,
color=chromosome_colors[chrom],</p>
<blockquote class="last">
<div>label=&#8221;Chrom {}&#8221;.format(chrom))</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>#handles, labels = ax[sp].get_legend_handles_labels()
ax[sp].set_xlabel(&#8220;Effect&#8221;)
ax[sp].set_ylabel(&#8220;Frequency&#8221;)
ax[sp].set_title(r&#8217;${gen}$&#8217;.format(gen=generation_labels[sp]),</p>
<blockquote>
<div>fontsize=12)</div></blockquote>
<p>ax[sp].legend(loc=&#8217;best&#8217;)</p>
</div></blockquote>
<dl class="docutils">
<dt>f.suptitle(plot_title,</dt>
<dd>fontsize=24)</dd>
</dl>
<p>f.savefig(plot_file_name, dpi=300)</p>
<p class="last">return effect_frq_by_chromosome</p>
</dd>
<dt>class MetaData(object):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
The wgs is extensively paramterized. Hence changing one parameter will potentially produce a significantly different
result in the final population. Therefore, a set of replications is defined by a particular of parameterization.
The parameterization will be described in a metadata document. The class MetaData is responsible for collecting
the parameterization information and processing it into a writable file.
&#8220;&#8221;&#8220;</p>
<dl class="docutils">
<dt>def __init__(self, prefounders, founders, population_sizes, allele_effect_information,</dt>
<dd><blockquote class="first">
<div>allele_effects_table, metadata_filename):</div></blockquote>
<p>&#8220;&#8221;&#8221;
An instance of MetaData should have enough information to completely specify a population without using any
external information.
:param prefounders: Prefounder population of the 26 lines which were used to make the NAM population.
:param founders: Subset of prefounders used to make a derived population.
:param population_sizes: Size of the population during the F_one, F_two, &#8216;mate-and-merge&#8217; phase and finally
the selection phase.
:param allele_effect_information: Information about the distribution of allele effects and the corresponding
parameters, the random number generator package and random seed used to generate the allele effects.</p>
<blockquote>
<div>Ex: normal(0, 1), numpy.random, seed 1337.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param allele_effects_table:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">The actual tabular/dictionary representation of the realized allele effect values.</td>
</tr>
</tbody>
</table>
<p>&#8220;&#8221;&#8221;
self.prefounders = prefounders
self.founders = founders
self.population_sizes = population_sizes
self.allele_effect_information = allele_effect_information
self.allele_effects_table = allele_effects_table
self.metadata_filename = metadata_filename</p>
<p class="last"># A master function will use other functions to write the necessary information to file.</p>
</dd>
</dl>
<p>&#64;staticmethod
def ascii_chromosome_representation(pop, reduction_factor, metadata_filename):</p>
<blockquote>
<div><p>&#8220;&#8221;&#8221;
Writes a ascii representation of chromosomes with uninteresting loci
as * and QTL as <a href="#id1"><span class="problematic" id="id2">|</span></a>. The representation is has scale 1 /
reduction_factor to make it viable to put into a .txt document.
:param pop:
:param reduction_factor:
:param metadata_filename:
&#8220;&#8221;&#8221;
reduced_chromosomes = [math.floor(chrom/reduction_factor) for chrom in list(pop.numLoci())]
reduced_qtl = [math.floor(pop.chromLocusPair(locus)[1]/reduction_factor) for locus in pop.dvars().properQTL]
chromosomes_of_qtl = [pop.chromLocusPair(qtl)[0] for qtl in pop.dvars().properQTL]
aster_chroms = [[&#8216;*&#8217;]*chrom_len for chrom_len in reduced_chromosomes]
for red_qtl, chrom_of_qtl in zip(reduced_qtl, chromosomes_of_qtl):</p>
<blockquote>
<div>aster_chroms[chrom_of_qtl][red_qtl] = &#8216;|&#8217;</div></blockquote>
<dl class="docutils">
<dt>with open(metadata_filename, &#8216;a&#8217;) as chrom_file:</dt>
<dd><p class="first">chrom_file.write(&#8216;Scale: 1/%dn&#8217; % reduction_factor)
for idx, chrom in enumerate(aster_chroms):</p>
<blockquote class="last">
<div>idx += 1
chrom_file.write(&#8216;Chromosome: %dn&#8217; % idx)
chrom_file.write(&#8216;&#8217;.join(chrom) + &#8216;n&#8217;)</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>&#64;staticmethod
def coefficient_of_dispersion(pop):</p>
<blockquote>
<div><p>&#8220;&#8221;&#8221;
Mean to variance ratio of pairwise sequential distances of quantitative trait loci.
Note that this statistic contributes nothing if there is only one qtl on a chromosome.
:param pop:
&#8220;&#8221;&#8221;
chrom_loc_pairs = [pop.chromLocusPair(pop.dvars().properQTL[i]) for i in range(len(pop.dvars().properQTL))]
chromosomes = [chrom_loc_pairs[i][0] for i in range(len(chrom_loc_pairs))]
diffs = []
for i in range(len(chrom_loc_pairs)):</p>
<blockquote>
<div><dl class="docutils">
<dt>if chromosomes[i-1] == chromosomes[i]:</dt>
<dd>diffs.append(math.fabs(chrom_loc_pairs[i-1][1] - chrom_loc_pairs[i][1]))</dd>
</dl>
</div></blockquote>
<p>diffs = np.array(diffs)
mean = np.mean(diffs)
var = np.var(diffs)
var_to_mean_ratio = var/mean
return var_to_mean_ratio</p>
</div></blockquote>
<p>&#64;staticmethod
def genomic_dispersal(pop):</p>
<blockquote class="last">
<div><p>&#8220;&#8221;&#8221;
Genomic dispersal is a novel statistics which measures the spread of loci over a genome.z All loci of a chromosome
are compared to the center of the genetic map (in cMs) and weighted by the length of that chromosome.
:param pop: Population used for recurrent selection
:return: Dimensionless constant describing the parameterization
&#8220;&#8221;&#8221;
chrom_loc_pairs = [pop.chromLocusPair(pop.dvars().properQTL[i]) for i in range(len(pop.dvars().properQTL))]
chromosomes = [chrom_loc_pairs[i][0] for i in range(len(chrom_loc_pairs))]
qtl_positions = [(chrom_loc_pairs[i][1]) for i in range(len(chrom_loc_pairs))]
chromosome_midpoints = {i: (pop.numLoci()[i]/2) for i in range(len(pop.numLoci()))}
diffs = []
for pos, chrom, i in zip(qtl_positions, chromosomes, range(len(chrom_loc_pairs))):</p>
<blockquote>
<div>diffs.append(pos - chromosome_midpoints[chrom])</div></blockquote>
<p>squared_diffs = np.square(np.array(diffs))
root_squared_diffs = np.sqrt(squared_diffs)
denominator_lengths = np.array(list(pop.numLoci()))
pre_genetic_dispersal = np.divide(root_squared_diffs, denominator_lengths)
genomic_dispersal = sum(pre_genetic_dispersal)
return genomic_dispersal</p>
</div></blockquote>
</dd>
<dt>class PCA(object):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Class for performing principal component analyis on genotype matrices.
Test for population structure significance tests the largest eigenvalue
of the genotype covarience matrix. Details can be found in the paper:
Population Structure and Eigenanalysis Patterson et al 2006.
&#8220;&#8221;&#8221;
def __init__(self, pop, loci, qt_data):</p>
<blockquote>
<div>self.pop = pop
self.loci = loci
self.qt_data = qt_data</div></blockquote>
<dl class="last docutils">
<dt>def __str__(self):</dt>
<dd><dl class="first last docutils">
<dt>return &#8220;Parameters: PopSize {}, Number of Loci: {}, &#8221; </dt>
<dd><dl class="first last docutils">
<dt>&#8220;Keys of Data: {}.&#8221;.format(self.pop.popSize(), len(self.loci),</dt>
<dd>self.qt_data.keys())</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def calculate_count_matrix(self, pop, alleles, count_matrix_filename):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
A function to calculate the copy numbers of either the minor or
major allele for each individual at each locus. Minor or major
alleles parameter is a single set of alleles which determines if the
return is the minor or major allele count matrix.
:param pop:
:param alleles:
:param count_matrix_filename:
&#8220;&#8221;&#8221;
comparison_array = [alleles[locus] for locus in range(pop.totNumLoci())]
count_matrix = np.zeros((pop.popSize(), len(alleles)))
for i, ind in enumerate(pop.individuals()):</p>
<blockquote>
<div><dl class="docutils">
<dt>alpha = np.equal(np.array(comparison_array), ind.genotype(</dt>
<dd>ploidy=0), dtype=np.int8)</dd>
<dt>beta = np.equal(np.array(comparison_array), ind.genotype(ploidy=1),</dt>
<dd>dtype=np.int8)</dd>
</dl>
<p>counts = np.add(alpha, beta, dtype=np.int8)
count_matrix[i, :] = counts</p>
</div></blockquote>
<p class="last">np.savetxt(count_matrix_filename, count_matrix, fmt=&#8221;%d&#8221;)
return count_matrix</p>
</dd>
<dt>def svd(self, pop, count_matrix):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;</p>
<p>Follows procedure of Population Structure and Eigenanalysis
Patterson et al 2006.
Constructs a genotype matrix of bi-allelic loci where each entry is
the number of copies of the major allele at each locus. The genotype
matrix has dimensions (number_of_individuals)*(number_of_markers).
:param pop:
:param count_matrix:</p>
<p>&#8220;&#8221;&#8221;
shift = np.apply_along_axis(np.mean, axis=1, arr=count_matrix)
p_vector = np.divide(shift, 2)
scale = np.sqrt(np.multiply(p_vector, (1-p_vector)))</p>
<p>shift_matrix = np.zeros((pop.popSize(), pop.totNumLoci()))
scale_matrix = np.zeros((pop.popSize(), pop.totNumLoci()))
for i in range(pop.totNumLoci()):</p>
<blockquote>
<div>shift_matrix[:, i] = shift
scale_matrix[:, i] = scale</div></blockquote>
<p>corrected_matrix = (count_matrix - shift_matrix)/scale_matrix
# singular value decomposition using scipy linalg module
eigenvectors, s, v = linalg.svd(corrected_matrix)
eigenvalues = np.diagonal(np.square(linalg.diagsvd(s, pop.popSize(),</p>
<blockquote>
<div>pop.totNumLoci()))).T</div></blockquote>
<p class="last">sum_of_eigenvalues = np.sum(eigenvalues)
fraction_of_variance = np.divide(eigenvalues, sum_of_eigenvalues)
eigen_data = {}
eigen_data[&#8216;vectors&#8217;] = eigenvectors
eigen_data[&#8216;values&#8217;] = eigenvalues
eigen_data[&#8216;fraction_variance&#8217;] = fraction_of_variance
return eigen_data</p>
</dd>
<dt>def test_statistic(self, pop, eigenvalues):</dt>
<dd><p class="first">sum_of_eigenvalues = np.sum(eigenvalues)
n_hat_numerator = (pop.popSize() + 1)*sum_of_eigenvalues
n_hat_denom = (pop.popSize()-1)*sum_of_eigenvalues - sum_of_eigenvalues
n_hat = n_hat_numerator/n_hat_denom
lowercase_l = (pop.popSize() - 1)*eigenvalues[0]
mu_hat = np.square((np.sqrt(n_hat - 1) +</p>
<blockquote>
<div>np.sqrt(pop.popSize()))) / n_hat</div></blockquote>
<dl class="docutils">
<dt>sigma_hat = ((np.sqrt(n_hat - 1) + np.sqrt(pop.popSize()))/n_hat) * </dt>
<dd><dl class="first last docutils">
<dt>(((1/np.sqrt(n_hat - 1)) + 1/np.sqrt(pop.popSize())) ** (</dt>
<dd>1 / 3.0))</dd>
</dl>
</dd>
</dl>
<p class="last">test_statistic = (lowercase_l - mu_hat) / sigma_hat
return test_statistic</p>
</dd>
</dl>
</dd>
<dt>class GWAS(object):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
A class to collect and format all data in preparation for GWAS using TASSEL.
&#8220;&#8221;&#8220;</p>
<dl class="last docutils">
<dt>def __init__(self, pop, individual_names, locus_names, positions, <a href="#id3"><span class="problematic" id="id4">*</span></a>args,</dt>
<dd><blockquote class="first">
<div><a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs):</div></blockquote>
<p class="last">self.pop = pop
self.individual_names = individual_names
self.locus_names = locus_names
self.positions = positions</p>
</dd>
<dt>def hapmap_formatter(self, int_to_snp_conversions, hapmap_matrix_filename):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Converts genotype data from sim.Population object to HapMap file format
in expectation to be used in TASSEL for GWAS. At present the column
names will be hardcoded as will some of the values.
<code class="docutils literal"><span class="pre">hapmap_matrix_filename</span></code> is the name of the file the formatted
matrix will be written to.
:param int_to_snp_conversions:
:param hapmap_matrix_filename:
:return:
:rtype:
&#8220;&#8221;&#8221;
hapmap_data = {}
hapmap_data[&#8216;rs&#8217;] = self.locus_names
hapmap_data[&#8216;alleles&#8217;] = [&#8216;NA&#8217;]*self.pop.totNumLoci()
hapmap_data[&#8216;chrom&#8217;] = [self.pop.chromLocusPair(locus)[0]+1 for</p>
<blockquote>
<div>locus in
range(self.pop.totNumLoci())]</div></blockquote>
<p>hapmap_data[&#8216;pos&#8217;] = self.positions</p>
<p># Several columns which are set to &#8216;NA&#8217;.
extraneous_columns = [&#8216;strand&#8217;, &#8216;assembly&#8217;, &#8216;center&#8217;, &#8216;protLSID&#8217;,</p>
<blockquote>
<div>&#8216;assayLSID&#8217;, &#8216;panelLSID&#8217;, &#8216;QCcode&#8217;]</div></blockquote>
<dl class="docutils">
<dt>for column in extraneous_columns:</dt>
<dd>hapmap_data[column] = [&#8216;NA&#8217;]*self.pop.totNumLoci()</dd>
</dl>
<p># Each individual has a column. Simulated individuals will have names
# reflecting some information about them. &#8216;RS&#8217; recurrent selection,
# &#8216;R&#8217; rep, &#8216;G&#8217; generation and &#8216;I&#8217; ind_id</p>
<p># Finally each individual&#8217;s genotype must be converted to HapMap format</p>
<dl class="docutils">
<dt>for ind in self.pop.individuals():</dt>
<dd><p class="first">alpha, beta = ind.genotype(ploidy=0), ind.genotype(ploidy=1)
hapmap_data[self.individual_names[ind.ind_id]] = [</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>int_to_snp_conversions[a]+int_to_snp_conversions[b]</dt>
<dd>for a, b in zip(alpha, beta)]</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p># Need to guarantee that the column names are in same order as the
# genoype data. Iterate over individuals in population to build up a
#  list of names will guarantee that col names are in same order as
# the hapmap_data
ordered_names = [self.individual_names[ind.ind_id] for ind in</p>
<blockquote>
<div>self.pop.individuals()]</div></blockquote>
<dl class="docutils">
<dt>hapmap_ordered_columns = [&#8216;rs&#8217;, &#8216;alleles&#8217;, &#8216;chrom&#8217;, &#8216;pos&#8217;, &#8216;strand&#8217;,</dt>
<dd><dl class="first last docutils">
<dt>&#8216;assembly&#8217;, &#8216;center&#8217;, &#8216;protLSID&#8217;, &#8216;assayLSID&#8217;,</dt>
<dd>&#8216;panelLSID&#8217;, &#8216;QCcode&#8217;] + ordered_names</dd>
</dl>
</dd>
</dl>
<p>hapmap_matrix = pd.DataFrame(columns=hapmap_ordered_columns)
for k, v in hapmap_data.items():</p>
<blockquote>
<div>hapmap_matrix[k] = v</div></blockquote>
<dl class="docutils">
<dt>hapmap_matrix.to_csv(hapmap_matrix_filename, sep=&#8217;t&#8217;,</dt>
<dd>index=False)</dd>
</dl>
<p class="last">return hapmap_matrix</p>
</dd>
<dt>def trait_formatter(self, trait_filename):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Simple function to automate the formatting of the phenotypic data.
Because of the way the header must be written the file is opened in
append mode. Rewriting to the same file many times could introduce an
unsuspected bug.
:param trait_filename:
&#8220;&#8221;&#8221;
header = &#8220;&lt;Trait&gt; simn&#8221;</p>
<p># Ensure phenotype and name are coming from the same individual</p>
<p>phenotypes = []
ind_names = []
for ind in self.pop.individuals():</p>
<blockquote>
<div>phenotypes.append(ind.p)
ind_names.append(self.individual_names[ind.ind_id])</div></blockquote>
<p>trait_vector = pd.DataFrame([ind_names, phenotypes]).T</p>
<p>cwd = os.getcwd()
file_out_path = os.path.join(cwd, trait_filename)</p>
<dl class="docutils">
<dt>if os.path.exists(file_out_path):</dt>
<dd>os.remove(file_out_path)</dd>
<dt>with open(trait_filename, &#8216;a&#8217;) as f:</dt>
<dd>f.write(header)
trait_vector.to_csv(f, sep=&#8217; &#8216;, index=False, header=False)</dd>
</dl>
<p class="last">return trait_vector</p>
</dd>
<dt>def population_structure_formatter(self, eigen_data, structure_filename):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Writes the first two of the population structure matrix to a
file. First column of the file is are names.
:param structure_filename:
:param eigen_data:
&#8220;&#8221;&#8220;</p>
<dl class="docutils">
<dt>ordered_names = [self.individual_names[ind.ind_id] for ind in</dt>
<dd>self.pop.individuals()]</dd>
<dt>structure_matrix = pd.DataFrame([list(eigen_data[&#8216;vectors&#8217;][:, 0].T),</dt>
<dd>list(eigen_data[&#8216;vectors&#8217;][:, 1].T)]).T</dd>
</dl>
<p>structure_matrix.index = ordered_names</p>
<p>header = &#8220;&lt;Covariate&gt;ttn&lt;Trait&gt;td1td2n&#8221;</p>
<p>cwd = os.getcwd()
file_out_path = os.path.join(cwd, structure_filename)</p>
<dl class="docutils">
<dt>if os.path.exists(file_out_path):</dt>
<dd>os.remove(file_out_path)</dd>
<dt>with open(structure_filename, &#8216;a&#8217;) as f:</dt>
<dd>f.write(header)
structure_matrix.to_csv(f, sep=&#8217;t&#8217;, index=True, header=False)</dd>
</dl>
<p class="last">return structure_matrix</p>
</dd>
<dt>def calc_kinship_matrix(self, allele_counts, allele_data,</dt>
<dd><blockquote class="first">
<div>kinship_filename):</div></blockquote>
<p>&#8220;&#8221;&#8221;
Calculates the kinship matrix according to VanRaden 2008:
Efficient Methods to Compute Genomic Predictions and writes it to a
file formatted for Tassel. The variable names try to be consistent
with the variable names in the paper.</p>
<p>The allele frequencies used for this function are with respect to
the base population or G0: after random mating and before selection.
:param allele_counts:
:param allele_data:
:param kinship_filename:
:return:
:rtype:
&#8220;&#8221;&#8220;</p>
<p>M = np.matrix(allele_counts - 1)</p>
<dl class="docutils">
<dt>major_allele_frequencies = </dt>
<dd><dl class="first last docutils">
<dt>np.array([allele_data[&#8216;major&#8217;, &#8216;frequency&#8217;, 0][locus]</dt>
<dd>for locus in range(self.pop.totNumLoci())])</dd>
</dl>
</dd>
</dl>
<p>P = 2*(major_allele_frequencies - 0.5)</p>
<p>Z = M - P</p>
<p>scaling_factor = sum(2*P*(1 - P))</p>
<p>G = (Z*Z.T)/scaling_factor</p>
<dl class="docutils">
<dt>annotated_G = pd.DataFrame(G, index=[self.individual_names[ind.ind_id]</dt>
<dd>for ind in
self.pop.individuals()])</dd>
</dl>
<p># Tassel example has number of individuals in the header of the G
# matrix file
header = &#8220;{}n&#8221;.format(self.pop.popSize())</p>
<p>cwd = os.getcwd()
file_out_path = os.path.join(cwd, kinship_filename)</p>
<dl class="docutils">
<dt>if os.path.exists(file_out_path):</dt>
<dd>os.remove(file_out_path)</dd>
<dt>with open(kinship_filename, &#8216;a&#8217;) as f:</dt>
<dd>f.write(header)
annotated_G.to_csv(f, sep=&#8217; &#8216;, index=True, header=False)</dd>
</dl>
<p class="last">return annotated_G</p>
</dd>
</dl>
</dd>
<dt>def generate_tassel_gwas_configs(input_directory_prefix,</dt>
<dd><blockquote class="first">
<div>out_directory_prefix,
config_file_prefix,
run_identifier_prefix,
xml_pipeline_template):</div></blockquote>
<p>&#8220;&#8221;&#8221;
Creates an xml file to run TASSEL using a mixed linear model approach.
Assumes use of hapmap, kinship, phenotype and population structure files.</p>
<p>The TASSEL command line interface requires a considerable number of
options to run GWAS. It is impractical to run the command line manually
for the number of replications in a simulated study. The TASSEL command
line interface allows the user to input a .xml file with the same
information which is used in the terminal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param input_directory_prefix:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Directory path to send the input files.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param run_identifier_prefix:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Identifier for single replicate of data</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">param xml_pipeline_template:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">XML file already setup for running a</td>
</tr>
</tbody>
</table>
<p>specific kind of GWAS
:return: XML file to run a single replicate of data using TASSEL
&#8220;&#8221;&#8220;</p>
<p>import xml.etree.ElementTree as ET
import lxml.etree as etree</p>
<p>tree = ET.parse(xml_pipeline_template)
root = tree.getroot()
lxml_tree = etree.fromstring(ET.tostring(root))
lxml_root = lxml_tree.getroottree()</p>
<dl class="docutils">
<dt>lxml_root.find(&#8216;fork1/h&#8217;).text = os.path.join(input_directory_prefix,</dt>
<dd>run_identifier_prefix +
&#8216;simulated_hapmap.txt&#8217;)</dd>
<dt>lxml_root.find(&#8216;fork2/t&#8217;).text = os.path.join(input_directory_prefix,</dt>
<dd>run_identifier_prefix +
&#8216;phenotype_vector.txt&#8217;)</dd>
<dt>lxml_root.find(&#8216;fork3/q&#8217;).text = os.path.join(input_directory_prefix,</dt>
<dd>run_identifier_prefix +
&#8216;structure_matrix.txt&#8217;)</dd>
<dt>lxml_root.find(&#8216;fork4/k&#8217;).text = os.path.join(input_directory_prefix,</dt>
<dd>run_identifier_prefix +
&#8216;kinship_matrix.txt&#8217;)</dd>
<dt>lxml_root.find(&#8216;combine6/export&#8217;).text = os.path.join(</dt>
<dd>out_directory_prefix, run_identifier_prefix +&#8217;<a href="#id15"><span class="problematic" id="id16">gwas_out_</span></a>&#8216;)</dd>
</dl>
<p>xml_file_name = run_identifier_prefix + &#8216;sim_gwas_pipeline.xml&#8217;
config_file_out = os.path.join(config_file_prefix, run_identifier_prefix</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;sim_gwas_pipeline.xml&#8217;)</li>
</ul>
</div></blockquote>
<dl class="last docutils">
<dt>lxml_root.write(config_file_out, encoding=&#8221;UTF-8&#8221;,</dt>
<dd><dl class="first last docutils">
<dt>method=&#8221;xml&#8221;, xml_declaration=True, standalone=&#8217;&#8216;,</dt>
<dd>pretty_print=True)</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def parameter_set_writer(directory_prefix, run_prefix, mating,</dt>
<dd><blockquote class="first">
<div>quantitative, effects,
genetic_structure):</div></blockquote>
<p>&#8220;&#8221;&#8221;
Simulation parameters are collected in separate dictionary objects.
This function writes all parameter information into a set of human
readable .yaml files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param directory_prefix:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param run_prefix:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Identifier for a set of simulated data</td>
</tr>
<tr class="field-odd field"><th class="field-name">param mating:</th><td class="field-body">Parameters which specifying mating</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param quantitative:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Dictionary of qtl for each replicate</td>
</tr>
<tr class="field-odd field"><th class="field-name">param effects:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param genetic_structure:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>&#8220;&#8221;&#8220;</p>
<p>import yaml</p>
<p>file_names = {}</p>
<p>file_names[run_prefix + &#8216;mating.yaml&#8217;] = mating
file_names[run_prefix + &#8216;qtl.yaml&#8217;] = quantitative
file_names[run_prefix + &#8216;allele_effects.yaml&#8217;] = effects
file_names[run_prefix + &#8216;genetic_structure.yaml&#8217;] = genetic_structure</p>
<dl class="last docutils">
<dt>for name, param_set in file_names.items():</dt>
<dd><dl class="first last docutils">
<dt>with open(name, &#8216;w&#8217;) as p_stream:</dt>
<dd>yaml.dump(param_set, p_stream)</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def parameter_set_reader(parameter_filename):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Reads a file of .yaml parameters for an easy way to parameterize a
simulation. Alternately the user would have to derive a great deal of
information from raw files.
:param parameter_filename:
:return:
&#8220;&#8221;&#8220;</p>
<p class="last">pass</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/analyze.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">saegus 0.1.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, John J. Dougherty III.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>