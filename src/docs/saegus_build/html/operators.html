<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>&lt;no title&gt; &mdash; saegus 0.1.2 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="saegus 0.1.2 documentation" href="contents.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">saegus 0.1.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>All of the classes in this module are derived from the simuPOP.PyOperator
class. Each class performs some task inside of the evolutionary process.
simuPOP offers a standard library of operators for common population genetics
processes. The operators defined in this module perform operations which
would either be impossible or difficult to implement using standard simuPOP
operators.</p>
<dl class="docutils">
<dt>class GenoAdditive(sim.PyOperator):</dt>
<dd><dl class="first last docutils">
<dt>def __init__(self, absolute_qtl, allele_effects, <a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs):</dt>
<dd><p class="first">self.absolute_qtl = absolute_qtl
self.allele_effects = allele_effects
sim.PyOperator.__init__(self,</p>
<blockquote class="last">
<div>func=self.additive_model,
<a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs)</div></blockquote>
</dd>
<dt>def additive_model(self, pop):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Calculates genotypic contribution <code class="docutils literal"><span class="pre">g</span></code> by summing the effect of each
allele at each QTL triplet.
&#8220;&#8221;&#8221;
rep_id = pop.dvars().rep
for ind in pop.individuals():</p>
<blockquote>
<div><dl class="docutils">
<dt>genotypic_contribution = </dt>
<dd><dl class="first last docutils">
<dt>sum([self.allele_effects[rep_id][locus][ind.genotype(ploidy=0)[</dt>
<dd><dl class="first last docutils">
<dt>locus]] +</dt>
<dd><dl class="first docutils">
<dt>self.allele_effects[rep_id][locus][ind.genotype(ploidy=1)[</dt>
<dd>locus]]</dd>
</dl>
<p class="last">for
locus
in self.absolute_qtl[rep_id]])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>ind.g = genotypic_contribution</p>
</div></blockquote>
<p class="last">return True</p>
</dd>
</dl>
</dd>
</dl>
<p><code class="xref py py-class docutils literal"><span class="pre">CalculateErrorVariance</span></code></p>
<blockquote>
<div><p>An operator to calculate the variance of the experimental error distribution.
We assume that there is some degree of error when measuring phenotypes in
an actual experiment. Measurement error is represented as a random draw
from a normal distribution with mean zero and variance <code class="docutils literal"><span class="pre">epsilon</span></code> where</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">epsilon</span></code> = <code class="docutils literal"><span class="pre">genotypic_variance</span></code> * (1/<code class="docutils literal"><span class="pre">heritability</span></code> - 1)</div></blockquote>
<p><code class="docutils literal"><span class="pre">epsilon</span></code> is assigned as a population variable. This operator is typically
called once in the initOps phase of an evolutionary process. At present
<code class="xref py py-class docutils literal"><span class="pre">CalculateErrorVariance</span></code> is hard coded to calculate
<code class="docutils literal"><span class="pre">genotypic_variance</span></code> as the sample variance of the infoField <code class="docutils literal"><span class="pre">g</span></code>.</p>
<p>Population must have infoField <code class="docutils literal"><span class="pre">g</span></code>, 0 &lt; heritability &lt; 1.
<code class="xref py py-class docutils literal"><span class="pre">GenoAdditive</span></code> must be called before class:<cite>CalculateErrorVariance</cite> or
values of <code class="docutils literal"><span class="pre">g</span></code> must be assigned to each individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param float heritability:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Floating point value greater than zero and less than 1.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="docutils">
<dt>class PhenotypeCalculator(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Under a purely additive model for the time being: P = G + error.
<code class="docutils literal"><span class="pre">error</span></code> is a random draw from a normal distribution with mean 0 and
variance determined by the variance in the pre-selection population.
The variance <code class="docutils literal"><span class="pre">epsilon</span></code> is calculated by another operator:
CalculateErrorVariance.
&#8220;&#8221;&#8221;
def __init__(self, proportion_selected, <a href="#id9"><span class="problematic" id="id10">*</span></a>args, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):</p>
<blockquote>
<div><p>self.proportion_selected = proportion_selected
sim.PyOperator.__init__(self, func=self.phenotypic_effect_calculator,</p>
<blockquote>
<div><a href="#id13"><span class="problematic" id="id14">*</span></a>args, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs)</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>def phenotypic_effect_calculator(self, pop):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Simulate measurement error by adding random error to genotypic
contribution.
&#8220;&#8221;&#8221;
for ind in pop.individuals():</p>
<blockquote>
<div>ind.p = ind.g + random.normalvariate(0, pop.dvars().epsilon)</div></blockquote>
<p class="last">return True</p>
</dd>
</dl>
</dd>
<dt>class CullPopulation(sim.PyOperator):</dt>
<dd><dl class="first last docutils">
<dt>def __init__(self, proportion_selected, <a href="#id17"><span class="problematic" id="id18">*</span></a>args, <a href="#id19"><span class="problematic" id="id20">**</span></a>kwargs):</dt>
<dd>self.proportion_selected = proportion_selected
sim.PyOperator.__init__(self, func=self.assign_fitness, <a href="#id21"><span class="problematic" id="id22">*</span></a>args, <a href="#id23"><span class="problematic" id="id24">**</span></a>kwargs)</dd>
<dt>def assign_fitness(self, pop, subPop):</dt>
<dd>pop.sortIndividuals(&#8216;p&#8217;, reverse=True)
p = pop.indInfo(&#8216;p&#8217;)
cutoff_index = -1*(int(self.proportion_selected*pop.popSize()) + 1)
cutoff = sorted(p)[cutoff_index]
pop.dvars().cutoff = cutoff
pop.setIndInfo([x &gt; cutoff for x in p], &#8216;fitness&#8217;)
return True</dd>
</dl>
</dd>
<dt>class Sorter(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Simple wrapper for Population.sortIndividuals() method.
&#8220;&#8221;&#8221;
def __init__(self, info_field, <a href="#id25"><span class="problematic" id="id26">*</span></a>args, <a href="#id27"><span class="problematic" id="id28">**</span></a>kwargs):</p>
<blockquote>
<div>self.info_field = info_field
sim.PyOperator.__init__(self, func=self.sort_on_info_field, <a href="#id29"><span class="problematic" id="id30">*</span></a>args, <a href="#id31"><span class="problematic" id="id32">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def sort_on_info_field(self, pop):</dt>
<dd>pop.sortIndividuals(self.info_field, reverse=True)
return True</dd>
</dl>
</dd>
<dt>class MetaPopulation(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Adds individuals to a meta population.
&#8220;&#8221;&#8221;
def __init__(self, meta_population, sample_size, <a href="#id33"><span class="problematic" id="id34">*</span></a>args, <a href="#id35"><span class="problematic" id="id36">**</span></a>kwargs):</p>
<blockquote>
<div><p>self.meta_population = meta_population
self.sample_size = sample_size
sim.PyOperator.__init__(self, func=self.add_to_meta_pop, <a href="#id37"><span class="problematic" id="id38">*</span></a>args,</p>
<blockquote>
<div><a href="#id39"><span class="problematic" id="id40">**</span></a>kwargs)</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>def add_to_meta_pop(self, pop):</dt>
<dd><dl class="first docutils">
<dt>sampled = sampling.drawRandomSample(pop,</dt>
<dd><dl class="first docutils">
<dt>sizes=self.sample_size[</dt>
<dd>pop.dvars().gen],</dd>
</dl>
<p class="last">subPops=sim.ALL_AVAIL)</p>
</dd>
</dl>
<p class="last">pop.dvars().ss = self.sample_size[pop.dvars().gen]
pop.dvars().gen_sampled_from = pop.dvars().gen
self.meta_population.addIndFrom(sampled)
return True</p>
</dd>
</dl>
</dd>
<dt>class ReplicateMetaPopulation(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator to sample individuals from the current generations to be added to a pre-initialized meta-population.
In the replicate case a population is mapped onto its corresponding replicate population by dictionary variable
&#8216;rep&#8217; which is assigned by simuPOP automatically during instantiation of a Simulator object.
param: Both replicates are assigned as attributes to a wgs.EnhancedPopulation object.
&#8220;&#8221;&#8221;
def __init__(self, meta_replicates, sample_size, <a href="#id41"><span class="problematic" id="id42">*</span></a>args, <a href="#id43"><span class="problematic" id="id44">**</span></a>kwargs):</p>
<blockquote>
<div>self.meta_replicates = meta_replicates
self.sample_size = sample_size
sim.PyOperator.__init__(self, func=self.add_to_meta_pop, <a href="#id45"><span class="problematic" id="id46">*</span></a>args, <a href="#id47"><span class="problematic" id="id48">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def add_to_meta_pop(self, pop):</dt>
<dd>rep_id = pop.dvars().rep
sampled = sampling.drawRandomSample(pop, sizes=self.sample_size[pop.dvars().gen])
pop.dvars().ss = self.sample_size[pop.dvars().gen]
pop.dvars().gen_sampled_from = pop.dvars().gen
self.meta_replicates.population(rep_id).addIndFrom(sampled)
return True</dd>
</dl>
</dd>
<dt>class TestReplicateMetaPopulation(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator which writes native simuPOP .pop files of each group of individuals sampled. This allows
us to data in the final metapopulation against the data as it is sampled at run-time. This operator
is to mainly address the concern that individuals are not being sampled from diferent generations through
an undetected bug in the code.
&#8220;&#8221;&#8221;
def __init__(self, meta_replicates, sample_size, <a href="#id49"><span class="problematic" id="id50">*</span></a>args, <a href="#id51"><span class="problematic" id="id52">**</span></a>kwargs):</p>
<blockquote>
<div>self.meta_replicates = meta_replicates
self.sample_size = sample_size
sim.PyOperator.__init__(self, func=self.add_to_meta_pop, <a href="#id53"><span class="problematic" id="id54">*</span></a>args, <a href="#id55"><span class="problematic" id="id56">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def add_to_meta_pop(self, pop):</dt>
<dd><p class="first">rep_id = pop.dvars().rep
sampled = sampling.drawRandomSample(pop, sizes=self.sample_size[pop.dvars().gen])
sampled_file_name = &#8216;<a href="#id105"><span class="problematic" id="id106">sampled_rep_</span></a>&#8216; + str(rep_id) + &#8216;_gen_&#8217; + str(pop.dvars().gen) + &#8216;_metapop.pop&#8217;
sampled.save(sampled_file_name)
pop.dvars().sampled_genotypes[pop.dvars().gen] = {}
for idx, individual in enumerate(pop.individuals()):</p>
<blockquote>
<div><dl class="docutils">
<dt>pop.dvars().sampled_genotypes[pop.dvars().gen] = [</dt>
<dd>individual.genotype(ploidy=0),
individual.genotype(ploidy=1)</dd>
</dl>
<p>]</p>
</div></blockquote>
<p class="last">pop.dvars().ss = self.sample_size[pop.dvars().gen]
pop.dvars().gen_sampled_from = pop.dvars().gen
self.meta_replicates.population(rep_id).addIndFrom(sampled)
return True</p>
</dd>
</dl>
</dd>
<dt>class StoreStatistics(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Stores means and variances of the aggregate, non-selected and selected
populations during an evolutionary process. Hard coded for my purposes
to collect certain data.</p>
<p>Sub-populations encoding:
(): aggregate
(0): selected
(1): non-selected
&#8220;&#8221;&#8221;
def __init__(self, <a href="#id57"><span class="problematic" id="id58">*</span></a>args, <a href="#id59"><span class="problematic" id="id60">**</span></a>kwargs):</p>
<blockquote>
<div>sim.PyOperator.__init__(self, func=self.store_statistics, <a href="#id61"><span class="problematic" id="id62">*</span></a>args, <a href="#id63"><span class="problematic" id="id64">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def store_statistics(self, pop):</dt>
<dd><dl class="first docutils">
<dt>pop.dvars().statistics[&#8216;aggregate&#8217;][&#8216;mean&#8217;, &#8216;g&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars().meanOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;selected&#8217;][&#8216;mean&#8217;, &#8216;g&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars(0).meanOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;non-selected&#8217;][&#8216;mean&#8217;, &#8216;g&#8217;, pop.dvars().gen]</dt>
<dd>= pop.dvars(1).meanOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;aggregate&#8217;][&#8216;var&#8217;, &#8216;g&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars().varOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;selected&#8217;][&#8216;var&#8217;, &#8216;g&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars(0).varOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;non-selected&#8217;][&#8216;var&#8217;, &#8216;g&#8217;, pop.dvars().gen]</dt>
<dd>= pop.dvars(1).varOfInfo[&#8216;g&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;aggregate&#8217;][&#8216;mean&#8217;, &#8216;p&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars().meanOfInfo[&#8216;p&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;selected&#8217;][&#8216;mean&#8217;, &#8216;p&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars(0).meanOfInfo[&#8216;p&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;non-selected&#8217;][&#8216;mean&#8217;, &#8216;p&#8217;, pop.dvars().gen]</dt>
<dd>= pop.dvars(1).meanOfInfo[&#8216;p&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;aggregate&#8217;][&#8216;var&#8217;, &#8216;p&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars().varOfInfo[&#8216;p&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;selected&#8217;][&#8216;var&#8217;, &#8216;p&#8217;, pop.dvars().gen] = </dt>
<dd>pop.dvars(0).varOfInfo[&#8216;p&#8217;]</dd>
<dt>pop.dvars().statistics[&#8216;non-selected&#8217;][&#8216;var&#8217;, &#8216;p&#8217;, pop.dvars().gen]</dt>
<dd>= pop.dvars(1).varOfInfo[&#8216;p&#8217;]</dd>
</dl>
<p class="last">return True</p>
</dd>
</dl>
</dd>
<dt>class SaveMetaPopulations(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator to sample individuals from the current generations to be added to a pre-initialized meta-population.
In the replicate case a population is mapped onto its corresponding replicate population by dictionary variable
&#8216;rep&#8217; which is assigned by simuPOP automatically during instantiation of a Simulator object.
param: Both replicates are assigned as attributes to a wgs.EnhancedPopulation object.
&#8220;&#8221;&#8221;
def __init__(self, meta_replicates, <a href="#id65"><span class="problematic" id="id66">*</span></a>args, <a href="#id67"><span class="problematic" id="id68">**</span></a>kwargs):</p>
<blockquote>
<div>self.meta_replicates = meta_replicates
sim.PyOperator.__init__(self, func=self.save_meta_pop_in_native_format, <a href="#id69"><span class="problematic" id="id70">*</span></a>args, <a href="#id71"><span class="problematic" id="id72">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def save_meta_pop_in_native_format(self, pop):</dt>
<dd>rep_id = pop.dvars().rep
meta_filename = &#8216;<a href="#id107"><span class="problematic" id="id108">replicate_</span></a>&#8216; + str(rep_id) + &#8216;_meta_pop.pop&#8217;
self.meta_replicates.population(rep_id).save(meta_filename)
return True</dd>
</dl>
</dd>
<dt>class InfoAndGenotypeWriter(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator to output values of individual infoFields and genotype matrix to file. Very similar
to simuPOP.utils.Exporter; however, allows for greater developmental flexibility.
&#8220;&#8221;&#8221;
def __init__(self, output_file_name: str, <a href="#id73"><span class="problematic" id="id74">*</span></a>args, <a href="#id75"><span class="problematic" id="id76">**</span></a>kwargs):</p>
<blockquote>
<div>&#8220;&#8221;&#8221;
output_file_name should not have a file extension.
&#8220;&#8221;&#8221;
self.output_file_name = output_file_name
sim.PyOperator.__init__(self, func=self.info_and_genotype_writer, <a href="#id77"><span class="problematic" id="id78">*</span></a>args, <a href="#id79"><span class="problematic" id="id80">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def info_and_genotype_writer(self, pop):</dt>
<dd><p class="first">full_file_name = self.output_file_name + &#8220;_&#8221; + str(pop.dvars().gen) + &#8221;.txt&#8221;
header = [&#8216;ind_id&#8217;, &#8216;mother_id&#8217;, &#8216;father_id&#8217;, &#8216;g&#8217;, &#8216;p&#8217;]
genotype_header = list(range(2*pop.totNumLoci()))
header.extend(genotype_header)
with open(full_file_name, &#8216;w&#8217;) as pop_info:</p>
<blockquote>
<div><p>info_writer = csv.writer(pop_info, delimiter=&#8217;,&#8217;)
info_writer.writerow(header)
for ind in pop.individuals():</p>
<blockquote>
<div><dl class="docutils">
<dt>info_writer.writerow([ind.ind_id, ind.mother_id,</dt>
<dd>ind.father_id, ind.g, ind.p,
ind.genotype()])</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p class="last">return True</p>
</dd>
</dl>
</dd>
<dt>class RandomlyAssignFemaleFitness(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Chooses <code class="docutils literal"><span class="pre">size_breeding_subpopulation</span></code> individuals to be eligible for
mating. 0 is the default value for <code class="docutils literal"><span class="pre">female_fitness</span></code>. Individuals who
have <code class="docutils literal"><span class="pre">female_fitness</span></code> = 0 cannot be picked as mates.
Individuals who have female fitness = 1 can be chosen as a &#8216;female&#8217;.
&#8220;&#8221;&#8221;
def __init__(self, size_breeding_subpopulation, <a href="#id81"><span class="problematic" id="id82">*</span></a>args, <a href="#id83"><span class="problematic" id="id84">**</span></a>kwargs):</p>
<blockquote>
<div>self.size_breeding_subpopulation = size_breeding_subpopulation
sim.PyOperator.__init__(self, func=self.choose_breeding_individuals_randomly, <a href="#id85"><span class="problematic" id="id86">*</span></a>args, <a href="#id87"><span class="problematic" id="id88">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def choose_breeding_individuals_randomly(self, pop):</dt>
<dd><p class="first">random_individual_ids = random.sample(list(pop.indInfo(&#8216;ind_id&#8217;)), self.size_breeding_subpopulation)
for id in random_individual_ids:</p>
<blockquote>
<div>pop.indByID(id).female_fitness = 1</div></blockquote>
<p class="last">return True</p>
</dd>
</dl>
</dd>
<dt>class RandomlyAssignMaleFitness(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator which parallels the purpose of RandomlyAssignFemaleFitness. Because we are working in a plant speices there
is the possibility of selfing. Thus breeding females are also counted as breeding males. In this case we supplement
the number of breeding females with an additional number of individuals who will only be used as males.
&#8220;&#8221;&#8221;
def __init__(self, additional_breeding_males, <a href="#id89"><span class="problematic" id="id90">*</span></a>args, <a href="#id91"><span class="problematic" id="id92">**</span></a>kwargs):</p>
<blockquote>
<div>self.additonal_breeding_males = additional_breeding_males
sim.PyOperator.__init__(self, func=self.randomly_choose_breeding_males, <a href="#id93"><span class="problematic" id="id94">*</span></a>args, <a href="#id95"><span class="problematic" id="id96">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def randomly_choose_breeding_males(self, pop):</dt>
<dd><p class="first">breeding_female_ids = [ind.ind_id for ind in pop.individuals() if ind.female_fitness == 1.0]
# Now every breeding female is also considered as a breeding male.
for female_id in breeding_female_ids:</p>
<blockquote>
<div>pop.indByID(female_id).male_fitness = 1.0</div></blockquote>
<p>non_breeding_ids = [ind.ind_id for ind in pop.individuals() if ind.ind_id not in breeding_female_ids]
additional_breeding_male_ids = random.sample(non_breeding_ids, self.additonal_breeding_males)
for male_id in additional_breeding_male_ids:</p>
<blockquote>
<div>pop.indByID(male_id).male_fitness = 1.0</div></blockquote>
<p class="last">return True</p>
</dd>
</dl>
</dd>
<dt>class DiscardRandomOffspring(sim.PyOperator):</dt>
<dd><p class="first">&#8220;&#8221;&#8221;
Operator to choose <code class="docutils literal"><span class="pre">number_to_remove</span></code> individuals at random to remove
from the offspring population. Simulates the effect of randomly picking
seed to plant from the larger population.
&#8220;&#8221;&#8221;
def __init__(self, number_to_remove, <a href="#id97"><span class="problematic" id="id98">*</span></a>args, <a href="#id99"><span class="problematic" id="id100">**</span></a>kwargs):</p>
<blockquote>
<div>self.number_to_remove = number_to_remove
sim.PyOperator.__init__(self, func=self.remove_indices, <a href="#id101"><span class="problematic" id="id102">*</span></a>args, <a href="#id103"><span class="problematic" id="id104">**</span></a>kwargs)</div></blockquote>
<dl class="last docutils">
<dt>def remove_indices(self, pop):</dt>
<dd>inds = list(range(pop.popSize()))
removed_inds = random.sample(inds, self.number_to_remove)
pop.removeIndividuals(removed_inds)
return True</dd>
</dl>
</dd>
</dl>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/operators.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">saegus 0.1.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, John J. Dougherty III.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>